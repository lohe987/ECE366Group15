add $8, $18,$0
add $10, $0, $8                      # To calculate the modulus 17 we make succesive substractions
add $10, $0, $14                     # If not: then current score will be saved as best score
add $10, $18, $0
add $13, $13, $14                    # We add the result of the hamming count. If it's zero, then nothing happens
add $13, $0, $0                      # We will be storing the hamming distance in $13, therefore, we load a 0
add $13, $10, $0
add $14, $8, $0
add $14, $10, $0                     # the base is elevated to the power of two
add $18, $18, $14      	             # We add the value $14 to the register $18
addi $8, $0, 1
addi $10, $0, 6                      # constant 6 is loaded into register 10
addi $10, $10, -17
addi $11, $11, -1
addi $12, $0, 0x2000                 # Load the data address in $12 useful for loading operands
addi $12, $0, 17                     # We load a 17 for the modulus
addi $13, $13, -1
addi $14, $0, 32
addi $15, $0, 0x2000                 # start address of the data is stored in $15
addi $15, $0, 0x2004                 # We store the address to which the result shall be saved in the register $15
addi $15, $0, 20                     # numbers of words in the array
addi $15, $15, -1                    # We must do this for all words in the array
addi $15, $0, 0                      # Counter of scores
addi $15, $15, 1                     # If they are equal, the score is incremented
addi $17, $17, 4                     #advance to next array word
addi $17, $15, 0xC                   # address of the array is stored in $17
addi $17, $17, 4                     # Move to the next position in the array
addi $17, $0, 0x2004
addi $17, $0, 0x205C                # Here we save start address of score array in $
addi $11, $0, 20                    # We store the number of words in the array, usfeul for oops
addi $17, $0, 0x2008                # We recover the given address to store result
addi $18, $0, 0
andi $11, $15, 1                   	# If not: it gets lowest bit value by andi operation between $15 and  1
andi $14, $16, 1                    # With the handy andi, we get the most significant bit
beq  $11, $0, Continue
beq  $11, $0, EndOfProgram
beq  $13, $0, ReturnToPrevious      # If one Operand is zero we return, since the result is zero
beq  $14, $0, ReturnToPrevious      # If one Operand is zero we return, since the result is zero
beq  $15, $0, ExponentZero          # If Exponent is Zero we go to ExponentZero
beq  $16, $0, endHamming
j    MainLoop                       #Jump to Mainloop
j    SecondaryLoop                  # We keep goint until $13 is zero
j    EXIT
j    Modulus                        # Keep calculating modulus
j    Hamming                        # Keep looping
j    LoopScores
jal  Multiplication
jal  Modulus
jal  IncrementCount
jr   $31
lw   $10, 4($15)                    # The current best matching score is loading into $10 from memory
lw   $11, 0($15)                    # pattern is loaded into $11
lw   $15, 0($12)                    # the exponent is loaded into 15
lw   $16, 0($17)                    # We load a score from array
slt  $11, $10, $12                  # If we found out that the number is already lower thant seventeen, then we're done
slt  $13, $14, $10                  # If the score is lower than the best, we will not save it
srl  $15, $15, 1                    # it advances to the next bit
srl  $16, $16, 1                    # We shift to compare with the next bit
sw   $8, 4($12)                     # it saves 1 in the result because if the exponent is 0
sw   $10, 0($17)                    # We save the best score in the given address
sw   $10, 0($15)       	            # We save the result
sw   $14, 80($17)                   # Calculate direction is score array
sw   $15, 0($17)                    # the result is stored back into data
xor  $16, $16, $11                  # The xor will give us the information needed to count for the hamming distance
