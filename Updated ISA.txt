0	00000000	add $8, $18,$0	
1	00000001	add $10, $0, $8                   	# To calculate the modulus 17 we make succesive substractions
2	00000010	add $10, $0, $14                    	# If not: then current score will be saved as best score
3	00000011	add $10, $18, $0	
4	00000100	add $13, $13, $14                   	# We add the result of the hamming count. If it's zero, then nothing happens
5	00000101	add $13, $0, $0                     	# We will be storing the hamming distance in $13, therefore, we load a 0
6	00000110	add $13, $10, $0	
7	00000111	add $14, $8, $0    	
8	00001000	add $14, $10, $0                   	# the base is elevated to the power of two
9	00001001	add $18, $18, $14      			# We add the value $14 to the register $18
10	00001010	addi $8, $0, 1	
11	00001011	addi $10, $0, 6                      	# constant 6 is loaded into register 10
12	00001100	addi $10, $10, -17  	
13	00001101	addi $11, $11, -1         	
14	00001110	addi $12, $0, 0x2000             	# Load the data address in $12 useful for loading operands
15	00001111	addi $12, $0, 17                   	# We load a 17 for the modulus
16	00010000	addi $13, $13, -1 	
17	00010001	addi $14, $0, 32	
18	00010010	addi $15, $0, 0x2000                 	# start address of the data is stored in $15
19	00010011	addi $15, $0, 0x2004                	# We store the address to which the result shall be saved in the register $15
20	00010100	addi $15, $0, 20                   	# numbers of words in the array
21	00010101	addi $15, $15, -1                   	# We must do this for all words in the array
22	00010110	addi $15, $0, 0                     	# Counter of scores
23	00010111	addi $15, $15, 1                    	# If they are equal, the score is incremented 
24	00011000	addi $17, $17, 4                     	# advance to next array word
25	00011001	addi $17, $15, 0xC                  	# address of the array is stored in $17
26	00011010	addi $17, $17, 4                    	# Move to the next position in the array
27	00011011	addi $17, $0, 0x2004     	
28	00011100	addi $17, $0, 0x205C                	# Here we save start address of score array in $
29	00011101	addi $11, $0, 20                    	# We store the number of words in the array, usfeul for oops
30	00011110	addi $17, $0, 0x2008               	# We recover the given address to store result
31	00011111	addi $18, $0, 0	

32	00100000	andi $11, $15, 1                   	# If not: it gets lowest bit value by andi operation between $15 and  1
33	00100001	andi $14, $16, 1                    	# With the handy andi, we get the most significant bit

34	00100010	beq  $11, $0, Continue 	
35	00100011	beq  $11, $0, EndOfProgram	
36	00100100	beq  $13, $0, ReturnToPrevious      	# If one Operand is zero we return, since the result is zero
37	00100101	beq  $14, $0, ReturnToPrevious     	# If one Operand is zero we return, since the result is zero
38	00100110	beq  $15, $0, ExponentZero         	# If Exponent is Zero we go to ExponentZero
39	00100111	beq  $16, $0, endHamming	

40	00101000	j    MainLoop                       	# Jump to Mainloop
41	00101001	j    SecondaryLoop                  	# We keep goint until $13 is zero
42	00101010	j    EXIT	
43	00101011	j    Modulus                        	# Keep calculating modulus
44	00101100	j    Hamming                        	# Keep looping
45	00101101	j    LoopScores
	
46	00101110	jal Multiplication	
47	00101111	jal Modulus	
48	00110000	jal IncrementCount
  	
49	00110001	jr  $31	

50	00110010	lw  $10, 4($15)                   	# The current best matching score is loading into $10 from memory
51	00110011	lw  $11, 0($15)                    	# pattern is loaded into $11
52	00110100	lw  $15, 0($12)                    	# the exponent is loaded into 15
53	00110101	lw  $16, 0($17)                    	# We load a score from array

54	00110110	slt $11, $10, $12                  	# If we found out that the number is already lower thant seventeen, then we're done
55	00110111	slt $13, $14, $10                 	# If the score is lower than the best, we will not save it

56	00111000	srl $15, $15, 1                    	# it advances to the next bit
57	00111001	srl $16, $16, 1                   	# We shift to compare with the next bit
   
58	00111010	sw  $8, 4($12)                    	# it saves 1 in the result because if the exponent is 0
59	00111011	sw  $10, 0($17)                    	# We save the best score in the given address
60	00111100	sw  $10, 0($15)       			# We save the result
61	00111101	sw  $14, 80($17)                  	# Calculate direction is score array
62	00111110	sw  $15, 0($17)                   	# the result is stored back into data

63	00111111	xor $16, $16, $11                  	# The xor will give us the information needed to count for the hamming distance
			