1	00000000	add $8, $18,$0	
2	00000001	add $10, $0, $8                   	# To calculate the modulus 17 we make succesive substractions
3	00000010	add $10, $0, $14                    	# If not: then current score will be saved as best score
4	00000011	add $10, $18, $0	
5	00000100	add $13, $13, $14                   	# We add the result of the hamming count. If it's zero, then nothing happens
6	00000101	add $13, $0, $0                     	# We will be storing the hamming distance in $13, therefore, we load a 0
7	00000110	add $13, $10, $0	
8	00000111	add $14, $8, $0    	
9	00001000	add $14, $10, $0                   	# the base is elevated to the power of two
10	00001001	add $18, $18, $14      			# We add the value $14 to the register $18
11	00001010	addi $8, $0, 1	
12	00001011	addi $10, $0, 6                      	# constant 6 is loaded into register 10
13	00001100	addi $10, $10, -17  	
14	00001101	addi $11, $11, -1         	
15	00001110	addi $12, $0, 0x2000             	# Load the data address in $12 useful for loading operands
16	00001111	addi $12, $0, 17                   	# We load a 17 for the modulus
17	00010000	addi $13, $13, -1 	
18	00010001	addi $14, $0, 32	
19	00010010	addi $15, $0, 0x2000                 	# start address of the data is stored in $15
20	00010011	addi $15, $0, 0x2004                	# We store the address to which the result shall be saved in the register $15
21	00010100	addi $15, $0, 20                   	# numbers of words in the array
22	00010101	addi $15, $15, -1                   	# We must do this for all words in the array
23	00010110	addi $15, $0, 0                     	# Counter of scores
24	00010111	addi $15, $15, 1                    	# If they are equal, the score is incremented 
25	00011000	addi $17, $17, 4                     	# advance to next array word
26	00011001	addi $17, $15, 0xC                  	# address of the array is stored in $17
27	00011010	addi $17, $17, 4                    	# Move to the next position in the array
28	00011011	addi $17, $0, 0x2004     	
29	00011100	addi $17, $0, 0x205C                	# Here we save start address of score array in $
30	00011101	addi $11, $0, 20                    	# We store the number of words in the array, usfeul for oops
31	00011110	addi $17, $0, 0x2008               	# We recover the given address to store result
32	00011111	addi $18, $0, 0	
33	00100000	andi $11, $15, 1                   	# If not: it gets lowest bit value by andi operation between $15 and  1
34	00100001	andi $14, $16, 1                    	# With the handy andi, we get the most significant bit
35	00100010	beq  $11, $0, Continue 	
36	00100011	beq  $11, $0, EndOfProgram	
37	00100100	beq  $13, $0, ReturnToPrevious      	# If one Operand is zero we return, since the result is zero
38	00100101	beq  $14, $0, ReturnToPrevious     	# If one Operand is zero we return, since the result is zero
39	00100110	beq  $15, $0, ExponentZero         	# If Exponent is Zero we go to ExponentZero
40	00100111	beq  $16, $0, endHamming	
41	00101000	j    MainLoop                       	# Jump to Mainloop
42	00101001	j    SecondaryLoop                  	# We keep goint until $13 is zero
43	00101010	j    EXIT	
44	00101011	j    Modulus                        	# Keep calculating modulus
45	00101100	j    Hamming                        	# Keep looping
46	00101101	j    LoopScores	
47	00101110	jal Multiplication	
48	00101111	jal Modulus	
49	00110000	jal IncrementCount  	
50	00110001	jr  $31	
51	00110010	lw  $10, 4($15)                   	# The current best matching score is loading into $10 from memory
52	00110011	lw  $11, 0($15)                    	# pattern is loaded into $11
53	00110100	lw  $15, 0($12)                    	# the exponent is loaded into 15
54	00110101	lw  $16, 0($17)                    	# We load a score from array
55	00110110	slt $11, $10, $12                  	# If we found out that the number is already lower thant seventeen, then we're done
56	00110111	slt $13, $14, $10                 	# If the score is lower than the best, we will not save it
57	00111000	srl $15, $15, 1                    	# it advances to the next bit
58	00111001	srl $16, $16, 1                   	# We shift to compare with the next bit   
59	00111010	sw  $8, 4($12)                    	# it saves 1 in the result because if the exponent is 0
60	00111011	sw  $10, 0($17)                    	# We save the best score in the given address
61	00111100	sw  $10, 0($15)       			# We save the result
62	00111101	sw  $14, 80($17)                  	# Calculate direction is score array
63	00111110	sw  $15, 0($17)                   	# the result is stored back into data
64	00111111	xor $16, $16, $11                  	# The xor will give us the information needed to count for the hamming distance
			